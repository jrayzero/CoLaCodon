from syntax_constants import *
from collections import *
from golomb import *
from generic_bitstream import *

@dataclass(init=False)
class AnnexBBitstream:
  # the current NAL unit payload under construction
  nal_payload: Bitstream 
  # the overall bitstream, which periodically gets written to file
  compressed: Bitstream
  fd: File

  def __init__(self, output_fn):
    self.nal_payload = Bitstream()
    self.compressed = Bitstream(32768)
    self.fd = open(output_fn, 'wb')

  def cleanup(self):
    self.compressed.flush(self.fd)
    self.fd.flush()
    self.fd.close()
    
  # once the nal_payload is complete, go through it byte-by-byte
  # and check for emulation bytes and then write to compressed
  def wrap_nal(self):
    # zero-byte, start_code_prefix_one_3bytes
    self.compressed.pack_with_flush(0x00000001, 32, self.fd)
    # go through the payload with a 3-width sliding window, replacing
    # 0x000001 with 0x00000301
    i = 0
    while i < (self.nal_payload.byte_idx-2):
      a = int(self.nal_payload.bits[i])
      b = int(self.nal_payload.bits[i+1])
      c = int(self.nal_payload.bits[i+2])
      window = (a << 18) | (b << 8) | c
      if window == 0x000001:
        self.compressed.pack_with_flush(0x00000301, 32, self.fd)
        i += 3
      else:
        self.compressed.pack_with_flush(a, 8, self.fd)
        i += 1
    for j in range(i,self.nal_payload.byte_idx):
      self.compressed.pack_with_flush(int(self.nal_payload.bits[j]), 8, self.fd)
    # add some zero padding so there isn't any emulation at the end
    self.compressed.pack_with_flush(0x00000000, 32, self.fd)
    self.compressed.flush(self.fd)

  def generate_sps(self, sps: SPS, state: EncoderState):
    self.nal_payload.reset()
    # forbidden_zero_bit
    self.nal_payload.pack(0, 1)
    # nal_profile_idc
    self.nal_payload.pack(NAL_REF_IDC_SPS, 2)
    # nal_unit_type
    self.nal_payload.pack(NAL_UNIT_TYPE_SPS, 5)
    # profile_idc
    self.nal_payload.pack(state.profile_idc, 8)
    # constraint flags
    self.nal_payload.pack(0, 6)
    # reserved_zero_2bits
    self.nal_payload.pack(0, 2)
    # level_idc
    self.nal_payload.pack(state.level_idc, 8)
    # seq_parameter_set_id
    golomb_ue(sps.sps_id, self.nal_payload)
    # log2_max_frame_num_minus4
    golomb_ue(0, self.nal_payload)
    # pic_order_cnt_type
    golomb_ue(0, self.nal_payload)
    # log2_max_pic_order_cnt_lsb_minus4
    golomb_ue(0, self.nal_payload)
    # max_num_ref_frames
    golomb_ue(0, self.nal_payload)
    # gaps_in_frame_num_value_allowed_flag
    self.nal_payload.pack(0, 1)
    # pic_width_in_mbs_minus1
    nmbs_wide = state.pic_W // 8
    if state.pic_W & 8 != 0:
      nmbs_wide += 1
    nmbs_wide -= 1
    golomb_ue(nmbs_wide, self.nal_payload)
    # pic_height_in_map_units_minus1
    nmbs_height = state.pic_H // 8
    if state.pic_H & 8 != 0:
      nmbs_height += 1
    nmbs_height -= 1
    golomb_ue(nmbs_height, self.nal_payload)    
    # frame_mbs_only_flag
    self.nal_payload.pack(1, 1)
    # direct_8x8_inference_flag
    self.nal_payload.pack(0, 1)
    # frame_cropping_flag
    self.nal_payload.pack(0, 1)
    # vui_parameters_present_flag
    self.nal_payload.pack(0, 1)
    
    self.nal_payload.rbsp_trailing_bits()
    
    
