from cola.blocks import *
from collections import *
from funcs import *
from transform import *
from quant import *

def residual4x4(A,B,out):
  for y in range(4):
    for x in range(4):
      out[y,x] = int(A(y,x))-int(B(y,x))

def intra_chroma_4x4_DC_1(pred, ref):
  offsets = tup_sub(pred.get_starts(), ref.get_starts())
  yoff,xoff = offsets[-2],offsets[-1]
  p = ref[pred]
  s = 4
  for v in p[:,-1-xoff]:
    s += v
  for v in p[-1-yoff,:]:
    s += v
  s >>= 3
  for y in range(4):
    for x in range(4):
      pred[y,x] = s  

def intra_chroma_4x4_DC_2(pred, ref):
  offsets = tup_sub(pred.get_starts(), ref.get_starts())
  yoff,xoff = offsets[-2],offsets[-1]
  p = ref[pred]
  s = 2
  for v in p[:,-1-xoff]:
    s += v
  s >>= 2
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_chroma_4x4_DC_3(pred, ref):
  offsets = tup_sub(pred.get_starts(), ref.get_starts())
  yoff,xoff = offsets[-2],offsets[-1]
  p = ref[pred]
  s = 2
  for v in p[-1-yoff,:]:
    s += v
  s >>= 2
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_chroma_4x4_DC_4(pred, bit_depth):
  s = (1<<(bit_depth-1))
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_4x4_vertical(pred, ref):
  p = ref[pred]
  for y in range(4):
    for x in range(4):
      pred[y,x] = p(-1,x)

def intra_4x4_horizontal(pred, ref):
  p = ref[pred]
  for y in range(4):
    for x in range(4):
      pred[y,x] = p(y,-1)

def intra_4x4_DC_1(pred, ref):
  p = ref[pred]
  s = 4
  for v in p[-1,:]:
    s += v
  for v in p[:,-1]:
    s += v
  s >>= 3
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_4x4_DC_2(pred, ref):
  p = ref[pred]
  s = 2
  for v in p[:,-1]:
    s += v
  s >>= 2
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_4x4_DC_3(pred, ref):
  p = ref[pred]
  s = 2
  for v in p[-1,:]:
    s += v
  s >>= 2
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_4x4_DC_4(pred, bit_depth):
  s = (1<<(bit_depth-1))
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def luma_intra_predict4x4(mb: Macroblock, video: Video):
  Y_mb = mb.Y_mb
  Y_inp = video.input_frame.Y
  Y_recons = video.recons_frame.Y
  qp = video.encoder_cfg.qp_init
  for smb8x8 in Y_mb.grid((8,8)):
    for smb4x4 in smb8x8.grid((4,4)):
      Ypred = Block[int,Tup2](smb4x4)
      # DC only currently
      if smb4x4[-1,-1].exists():
        intra_4x4_DC_1(Ypred, Y_recons)
      elif smb4x4[0,-1].exists():
        intra_4x4_DC_2(Ypred, Y_recons)
      elif smb4x4[-1,0].exists():
        intra_4x4_DC_3(Ypred, Y_recons) 
      else:
        intra_4x4_DC_4(Ypred, 8)
      cost = sad(Ypred, smb4x4)
      # forward
      residual = Block[int,Tup2](Ypred)
      residual4x4(smb4x4, Ypred, residual)
      dct4x4(residual,residual)
      basic_quantization(residual, residual, qp, video.quant)
      # entropy code
      # TODO
      # reconstruct
      pre_idct_scale(residual, Y_recons[residual], qp, video.quant)
      idct4x4(Y_recons[residual], Y_recons[residual])
      post_idct_scale(Y_recons[residual], Y_recons[residual])
      for i in range(4):
        for j in range(4):
          Y_recons[residual][i,j] = Y_recons[residual](i,j) + Ypred(i,j)
      rcost = sad(Y_recons[residual], smb4x4)

def chroma_part1(smb_4x4, pred_4x4, recons_4x4):
  # forward
  residual4x4(smb_4x4, pred_4x4, recons_4x4)
  dct4x4(recons_4x4, recons_4x4)

def chroma_part2(mb_8x8, recons_8x8, pred_8x8, qp, video):
  # more forward
  dcs_2x2 = recons_8x8[::4,::4]
  hadamard2x2(dcs_2x2, dcs_2x2)
  for recons_4x4 in recons_8x8.grid((4,4)):
    basic_quantization(recons_4x4, recons_4x4, qp, video.quant)
  # entropy code
  # TODO 
  # reconstruct
  ihadamard2x2(dcs_2x2, dcs_2x2)
  post_hadamard_chroma_DC_scale(dcs_2x2, dcs_2x2, qp, video.quant)
  for recons_4x4 in recons_8x8.grid((4,4)):
    dc00 = recons_4x4(0,0)
    pre_idct_scale(recons_4x4, recons_4x4, qp, video.quant)
    recons_4x4[0,0] = dc00 # not scaled, see 8.5.12.1 in spec
    idct4x4(recons_4x4, recons_4x4)
    post_idct_scale(recons_4x4, recons_4x4)
    for i in range(4):
      for j in range(4):
        recons_4x4[i,j] = recons_4x4(i,j) + pred_8x8[recons_4x4](i,j)  

def chroma_intra_predict4x4(mblk_8x8: Macroblock, video: Video):
  Cb_mb_8x8 = mblk_8x8.Cb_mb
  Cr_mb_8x8 = mblk_8x8.Cr_mb
  Cb_recons_frame = video.recons_frame.Cb
  Cr_recons_frame = video.recons_frame.Cr
  qp = video.encoder_cfg.qp_init
  Cb_recons_8x8 = Cb_recons_frame[Cb_mb_8x8]
  Cr_recons_8x8 = Cr_recons_frame[Cr_mb_8x8]
  # TODO: need to get the qpc from table 8-15
  y,x = Cb_mb_8x8.get_starts()
  # we need to store all 4x4 sub predictions in one 8x8 block
  Cb_pred_8x8 = Block[int,Tup2](Cb_mb_8x8)
  Cr_pred_8x8 = Block[int,Tup2](Cr_mb_8x8)
  # get the predictions, residuals, and dcts for each 4x4 block
  for Cb_smb_4x4,Cr_smb_4x4 in zip(Cb_mb_8x8.grid((4,4)), Cr_mb_8x8.grid((4,4))):
    # chroma is different from luma because it doesn't
    # use the reconstructions within the macroblock, 
    # but instead always uses data surrounding the macroblock
    Cb_pred_4x4 = Cb_pred_8x8[Cb_smb_4x4]
    Cr_pred_4x4 = Cr_pred_8x8[Cr_smb_4x4]
    if y>0 and x>0: 
      intra_chroma_4x4_DC_1(Cb_pred_4x4, Cb_recons_8x8)
      intra_chroma_4x4_DC_1(Cr_pred_4x4, Cr_recons_8x8)
    elif x>0:
      intra_chroma_4x4_DC_2(Cb_pred_4x4, Cb_recons_8x8)
      intra_chroma_4x4_DC_2(Cr_pred_4x4, Cr_recons_8x8)
    elif y>0:
      intra_chroma_4x4_DC_3(Cb_pred_4x4, Cb_recons_8x8)
      intra_chroma_4x4_DC_3(Cr_pred_4x4, Cr_recons_8x8)
    else:
      intra_chroma_4x4_DC_4(Cb_pred_4x4, 8)
      intra_chroma_4x4_DC_4(Cr_pred_4x4, 8)
    chroma_part1(Cb_smb_4x4, Cb_pred_4x4, Cb_recons_8x8[Cb_smb_4x4])
    chroma_part1(Cr_smb_4x4, Cr_pred_4x4, Cr_recons_8x8[Cr_smb_4x4])
  # now do the rest of the process
  chroma_part2(Cb_mb_8x8, Cb_recons_8x8, Cb_pred_8x8, qp, video)
  chroma_part2(Cr_mb_8x8, Cr_recons_8x8, Cr_pred_8x8, qp, video)

def intra_predict4x4(mb: Macroblock, video: Video):
  luma_intra_predict4x4(mb, video)
  chroma_intra_predict4x4(mb, video)
