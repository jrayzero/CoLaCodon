import sys
from cfg import *
from ..common.yuv import *
from parameter_sets import *
from encoder_processes import *
from video import *
from constants import *
from nal_unit import *
from slices import *
from quant import *

def init_SPS(cfg):
  sps = SPS()
  sps.profile_idc = cfg.profile
  sps.level_idc = cfg.level
  if cfg.profile == 66:
    sps.constraint_set1_flag = True
  if not cfg.disable_motion_estimation:
    assert False
  else:
    sps.pic_order_cnt_type = 0
  return sps

def init_PPS(cfg):
  pps = PPS()  
  pps.pic_init_qp_minus26 = cfg.qp_init - 26
  return pps

def main():
  if len(sys.argv) < 2:
    print 'Usage: h264.seq <cfg>'
  cfg = parse_config(sys.argv[1])
  video = Video(init_SPS(cfg), cfg, Bitstream(32768), open(cfg.output_fn, 'wb'))
  video.cfg = cfg
  video.sps = init_SPS(cfg)
  yuv420 = YUV420Reader(cfg)
  pps = init_PPS(cfg)
  # TODO add this to video
  quant_tables = QuantTables()
  frame_idx = 0
  encode_SPS(video.sps, video.cfg.height, video.cfg.width, video.bitstream, video.fd)
  # go through frames
  for Y_raw_frame,Cb_raw_frame,Cr_raw_frame in yuv420:
    print f'Frame: {frame_idx}'
    # build surrounding frame components
    encoder_frame = EncoderFrame(frame_idx, Y_raw_frame, Cb_raw_frame, Cr_raw_frame, pps)
    if frame_idx == 0:
      encode_PPS(pps, video.bitstream, video.fd)
    # build slice
    slice_nal = Bitstream()
    header = make_I_slice_header(frame_idx, frame_idx == 0)
    header.pic_order_cnt_lsb = 2*frame_idx 
    encode_pic_slice_header(header, video.sps, slice_nal)
    build_slice_payload(encoder_frame, video, quant_tables, slice_nal)
    finalize_nal_unit(video.bitstream, slice_nal, video.fd)
    frame_idx += 1
  yuv420.cleanup()
  video.fd.flush()
  video.fd.close()

main()
