import sys
from cfg import *
from ..common.yuv import *
from parameter_sets import *
from encoder_processes import *
from video import *
from constants import *
#from annexb import *
from nal_unit import *
from quant import *

def init_SPS(cfg):
  sps = SPS()
  sps.profile_idc = cfg.profile
  sps.level_idc = cfg.level
  if cfg.profile == 66:
    sps.constraint_set1_flag = True
  if not cfg.disable_motion_estimation:
    assert False
  else:
    sps.pic_order_cnt_type = 0
  return sps

def init_PPS(cfg):
  pps = PPS()  
  pps.pic_init_qp_minus26 = cfg.qp_init - 26
  return pps

def main():
  if len(sys.argv) < 2:
    print 'Usage: h264.seq <cfg>'
  cfg = parse_config(sys.argv[1])
  video = Video(init_SPS(cfg), cfg, Bitstream(32768), open(cfg.output_fn, 'wb'))
  video.cfg = cfg
  video.sps = init_SPS(cfg)
  yuv420 = YUV420Reader(cfg)
  pps = init_PPS(cfg)
  quant_tables = QuantTables()
  frame_idx = 0
  encode_SPS(video.sps, video.cfg.height, video.cfg.width, video.bitstream, video.fd)
  # go through frames
  for Y_raw_frame,Cb_raw_frame,Cr_raw_frame in yuv420:
    print f'Frame: {frame_idx}'
    encoder_frame = EncoderFrame(frame_idx, Y_raw_frame, Cb_raw_frame, Cr_raw_frame, pps)
    if frame_idx == 0:
      encode_PPS(pps, video.bitstream, video.fd)
    encoder_frame.pic_slice.header.pic_order_cnt_lsb = 2*frame_idx
    encoder_frame.encode(video, quant_tables)
    frame_idx += 1
  yuv420.cleanup()
#  video.bitstream.cleanup()
  video.fd.flush()
  video.fd.close()

main()
