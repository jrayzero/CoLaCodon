import sys
from cfg import *
from encoder import *
from h261_bitstream import *
from ..common.yuv import *

def main():
  if len(sys.argv) < 2:
    print 'Usage: h261.seq <cfg>'
  cfg = parse_config(sys.argv[1], parse_param, H261UserCfg)
  yuv420 = YUV420Reader(cfg)
  frame_idx = 0
  gop_idx = 0
  bitstream = H261Bitstream(cfg.output_fn)
  state = H261State(cfg.qp_init, cfg.cif, bitstream)
  # go through frames  
  intra_frame = True
  for Y_raw_frame,Cb_raw_frame,Cr_raw_frame in yuv420:
    # Figure out whether intra or inter
    # inter frames can contain intra, but not vice versa
    if cfg.frame_structure:
      # gop      
      frame_type = (cfg.gop >> (64-1-gop_idx)) & 0x1
      intra_frame = frame_type == 0
      sintra = 'intra' if intra_frame else 'inter'
      print f'Frame {frame_idx} is {sintra}'
    else:
      # period 
      frame_type = 0 if frame_idx % cfg.I_frame_period == 0 else 1
      intra_frame = frame_type == 0
      sintra = 'intra' if intra_frame else 'inter'
      print f'Frame {frame_idx} is {sintra}'
#    for i in range(Cb_raw_frame.get_dims()[0]):
#      for j in range(Cb_raw_frame.get_dims()[1]):
#        Cb_raw_frame[i,j] = byte(0)
#        Cr_raw_frame[i,j] = byte(0)
    # recons versions
    Y_rframe = Block[int,Tup2](Y_raw_frame)
    Cb_rframe = Block[int,Tup2](Cb_raw_frame)
    Cr_rframe = Block[int,Tup2](Cr_raw_frame)    
    frames = Pack(View(Y_raw_frame), View(Cb_raw_frame), View(Cr_raw_frame))
    rframes = Pack(View(Y_rframe), View(Cb_rframe), View(Cr_rframe))
    state.frame_idx = frame_idx
    state.is_intra_frame = intra_frame
    transmitted = PicLayer.process(frames, rframes, 0b000011 if not cfg.cif else 0b000111, state)
    frame_idx += 1
    gop_idx += 1
    gop_idx %= cfg.gop_size
    state.I_rframes = rframes
  yuv420.cleanup()
  bitstream.cleanup()

main()
