from cola.blocks import *
from ..common.typedefs import *
from dct import *
from quantize import *
from constants import *
from inter import *
from h261_bitstream import *
from tables import *
from cost import *

Q = 0

# A collection of Y, Cb, and Cr components
@tuple
class Pack[T]:
  Y: View[T,Tup2]
  Cb: View[T,Tup2]
  Cr: View[T,Tup2]

# any necessary parameters to pass around
@dataclass(init=False)
class H261State:
  # whether CIF
  cif: bool
  # The original quantization value
  qp_init: int
  # The current qp value
  qp: int
  # Whether intra or inter frame
  is_intra_frame: bool
  # Current frame index
  frame_idx: int
  # The bitstream
  bitstream: H261Bitstream
  # current gquant qp
  gquant: int
  # current mquant qp
  mquant: int
  # current macroblock idx
  midx: int
  # last macroblock idx
  l_midx: int
  # last mtype
  l_mtype: int
  # last y motion vector
  l_mvd_y: int
  # last x motion vector
  l_mvd_x: int
  # the prior encoded reconstructed I frames
  I_rframes: Optional[Pack[int]]

  def __init__(self, qp_init, cif, bitstream):
    self.qp_init = qp_init
    self.qp = qp_init
    self.gquant = qp_init
    self.mquant = qp_init
    self.cif = cif
    self.bitstream = bitstream
    self.is_intra_frame = False
    self.frame_idx = 0
    self.midx = 0
    self.l_midx = 0
    self.l_mtype = 0
    self.I_rframes = None

class PseudoBlockLayer:

  def _pseudo_add_sign():
    return 1

  def _pseudo_maybe_vlc(run,coeff):
    if run in tcoeff_vlc:
      run_info = tcoeff_vlc[run]
      if coeff in run_info:
        # vlc
        scoeff = coeff
        if coeff < 0:
          coeff = -coeff
        codeword,nbits = run_info[coeff]
        nbits += PseudoBlockLayer._pseudo_add_sign()
        return True,nbits
    return False,0

  def _pseudo_flc():
    return tcoeff_escape_nbits + 14

  # Don't actually write to bitstream--just figure out how many bits are needed
  # Entry point
  def pseudo_commit(rle, is_intra_mblk):
    cost = 0
    if not is_intra_mblk and len(rle) == 0:
      # don't need to transmit this block
      return cost
    # for coeff, if it is negative, you use the absolute value to actually look up 
    # in the VLC table.
    # for the FLC, you use the unsigned value
    # when using fixed run/level codes, its just the straightup bit representation
    if is_intra_mblk:
      cost += 8
    else:
      # the first transmitted level gets special treatment if run == 0 and coeff == 1
      first_run = rle[0]
      if first_run[0] == 0 and (first_run[1] == 1 or first_run[1] == -1):
        cost += 1
        cost += PseudoBlockLayer._pseudo_add_sign()
      else:
        zrun = first_run[0]
        coeff = first_run[1]
        res = PseudoBlockLayer._pseudo_maybe_vlc(zrun, coeff)
        if not res[0]:
          cost += PseudoBlockLayer._pseudo_flc()
        else:
          cost += res[1]
    for zrun,coeff in rle[1:]:
      if zrun == 0 and (coeff == 1 or coeff == -1):
        cost += 2
        cost += PseudoBlockLayer._pseudo_add_sign()
      else:
        res = PseudoBlockLayer._pseudo_maybe_vlc(zrun, coeff)
        if not res[0]:
          cost += PseudoBlockLayer._pseudo_flc()
        else:
          cost += res[1]
      first = False
    cost += tcoeff_EOB_nbits
    return cost

# No prediction actually happens at the block layer. Rather, this is what
# actually processes each 8x8 block   
class BlockLayer:

  # if is_intra == True, use special marker for the DC value
  def rle(coeffs, is_intra_mblk):
    # RLE in zigzag order
    # if intra, include the DC separately
    run = 0
    runs = []
    first = True
    for zz in zigzag:
      coeff = coeffs(*zz)
      if is_intra_mblk and first == True:
        dc = coeff
        runs.append((0,dc)) # special value
        first = False
        continue
      first = False
      if coeff == 0:
        run += 1
      else:
        runs.append((run,coeff))
        run = 0
    # don't need the last run because it'll just be EOB
    return runs

  def forward(coeffs, is_intra_mblk, qp):
#    print f'ERROR\n{coeffs.str_like(int)}'
    clip(coeffs, -256, 255)
    chen_DCT(coeffs)
    clip(coeffs, -2048, 2047)
#    print f'DCT\n{coeffs.str_like(int)}'
    if is_intra_mblk:
      intra_quantize(coeffs, qp) 
      dc = coeffs(0,0)
      if dc > 254:
        dc = 254
      elif dc < 1:
        dc = 1
      coeffs[0,0] = dc
    else:
      quantize(coeffs, qp)
#    print f'Quantized\n{coeffs.str_like(int)}'
    dc = coeffs(0,0)
    clip(coeffs, -127, 127)
    coeffs[0,0] = clip1(dc, 1, 254)

  def backward(coeffs, out_coeffs, is_intra_mblk, qp):
    if is_intra_mblk:
      intra_iquantize(coeffs, out_coeffs, qp)
    else:
      iquantize(coeffs, out_coeffs, qp)
    chen_IDCT(out_coeffs)
#    print out_coeffs.str_like(int)
#    exit(48)
    
  # add the prediction back on to the reconstruction
  def reconstruct(rblock, pred):
    for i in range(8):
      for j in range(8):
        rblock[i,j] = rblock(i,j) + pred(i,j)

  def process(error, pred, rblock, is_intra_mblk, state):
    # save the prediction because it gets added back in for the inter prediction reconstruction    
    BlockLayer.forward(error, is_intra_mblk, state.qp)
    rle = BlockLayer.rle(error, is_intra_mblk)
    BlockLayer.backward(error, rblock[error], is_intra_mblk, state.qp)
    if not is_intra_mblk:
      BlockLayer.reconstruct(rblock[error], pred)
    clip(rblock[error], 1, 254)  
    return rle
    
  def add_sign(coeff, bitstream):
    if coeff < 0:
      bitstream.compressed.pack(1,1)
    else:
      bitstream.compressed.pack(0,1)

  # see if there is a variable length code in the table, and use that if so
  # otherwise, returns false and need to use the fixed length code
  def maybe_vlc(run,coeff,bitstream):
    if run in tcoeff_vlc:
      run_info = tcoeff_vlc[run]
      if coeff in run_info:
        # vlc
        scoeff = coeff
        if coeff < 0:
          coeff = -coeff
        codeword,nbits = run_info[coeff]
        bitstream.compressed.pack(codeword,nbits)
        BlockLayer.add_sign(coeff, bitstream)
        return True
    return False

  def flc(run, coeff, bitstream):
    bitstream.compressed.pack(tcoeff_escape_codeword, tcoeff_escape_nbits)
    bitstream.compressed.pack(run, 6)
    bitstream.compressed.pack(coeff, 8)    

  def commit(rle, is_intra_mblock, bitstream):
    if not is_intra_mblock and len(rle) == 0:
      # don't need to transmit this block
      return False
    # for coeff, if it is negative, you use the absolute value to actually look up 
    # in the VLC table.
    # for the FLC, you use the unsigned value
    # when using fixed run/level codes, its just the straightup bit representation
    if is_intra_mblock:
      dc = rle[0][1]
      if dc == 128:
        bitstream.compressed.pack(0xFF,8)
      else:
        bitstream.compressed.pack(dc,8)
    else:
      # the first transmitted level gets special treatment if run == 0 and coeff == 1
      first_run = rle[0]
      if first_run[0] == 0 and (first_run[1] == 1 or first_run[1] == -1):
        bitstream.compressed.pack(1,1)
        BlockLayer.add_sign(first_run[1], bitstream)
      else:
        zrun = first_run[0]
        coeff = first_run[1]
        if not BlockLayer.maybe_vlc(zrun, coeff, bitstream):
          BlockLayer.flc(zrun, coeff, bitstream)
    for zrun,coeff in rle[1:]:
      if zrun == 0 and (coeff == 1 or coeff == -1):
        bitstream.compressed.pack(0b11,2) # not first coeff in block
        BlockLayer.add_sign(coeff, bitstream)
      else:
        if not BlockLayer.maybe_vlc(zrun, coeff, bitstream):
          BlockLayer.flc(zrun, coeff, bitstream)       
      first = False
    bitstream.compressed.pack(tcoeff_EOB_codeword, tcoeff_EOB_nbits)
    return True

class MacroblockLayer:

  def process_blocks(error_pack, pred_pack, is_intra_mblk, state):
    Y_pred,Cb_pred,Cr_pred = pred_pack
    Y_error,Cb_error,Cr_error = error_pack
    Y_recons = Block[int,Tup2](Y_pred)
    Cb_recons = Block[int,Tup2](Cb_pred)
    Cr_recons = Block[int,Tup2](Cr_pred)
    rpack = Pack(View(Y_recons),View(Cb_recons),View(Cr_recons))
    rle = []
    for Y in Y_pred.grid((8,8)):
      rle.append(BlockLayer.process(Y_error[Y], Y, Y_recons, is_intra_mblk, state))
    rle.append(BlockLayer.process(Cb_error, Cb_pred, Cb_recons, is_intra_mblk, state))    
    rle.append(BlockLayer.process(Cr_error, Cr_pred, Cr_recons, is_intra_mblk, state))
    return rpack,rle

  # Run intra prediction and store in temporaries
  def intra(mblks, state):
    Y,Cb,Cr = mblks
    Y_pred = Block[int,Tup2](Y)
    Cb_pred = Block[int,Tup2](Cb)
    Cr_pred = Block[int,Tup2](Cr)
    copy(Y_pred, Y)
    copy(Cb_pred, Cb)
    copy(Cr_pred, Cr)
    pred_pack = Pack(View(Y_pred),View(Cb_pred),View(Cr_pred))
#    print 'INTRA'
    a,b = MacroblockLayer.process_blocks(pred_pack, pred_pack, True, state)
    return a,b

  # inter-prediction without motion estimation
  # I_frame = the last I_frame sent which is used as reference
  def inter(mblks, state):
    Y,Cb,Cr = mblks
    # the predictions
    Y_pred = Block[int,Tup2](Y)
    Cb_pred = Block[int,Tup2](Cb)
    Cr_pred = Block[int,Tup2](Cr)
    # the residuals
    Y_error = Block[int,Tup2](Y)
    Cb_error = Block[int,Tup2](Cb)
    Cr_error = Block[int,Tup2](Cr)
    ref_Y_I_frame = state.I_rframes.Y
    ref_Cb_I_frame = state.I_rframes.Cb
    ref_Cr_I_frame = state.I_rframes.Cr
    copy(Y_pred, ref_Y_I_frame[Y])
    copy(Cb_pred, ref_Cb_I_frame[Cb])
    copy(Cr_pred, ref_Cr_I_frame[Cr])
    error(Y, Y_pred, Y_error)
    error(Cb, Cb_pred, Cb_error)
    error(Cr, Cr_pred, Cr_error)
    error_pack = Pack(View(Y_error),View(Cb_error),View(Cr_error))
    pred_pack = Pack(View(Y_pred),View(Cb_pred),View(Cr_pred))
#    print 'INTER'
    a,b = MacroblockLayer.process_blocks(error_pack, pred_pack, False, state)
    return a,b

  def inter_me(mblks, state):
    Y,Cb,Cr = mblks
    # the predictions
    Y_pred = Block[int,Tup2](Y)
    Cb_pred = Block[int,Tup2](Cb)
    Cr_pred = Block[int,Tup2](Cr)
    # the residuals
    Y_error = Block[int,Tup2](Y)
    Cb_error = Block[int,Tup2](Cb)
    Cr_error = Block[int,Tup2](Cr)
    ref_Y_I_frame = state.I_rframes.Y
    ref_Cb_I_frame = state.I_rframes.Cb
    ref_Cr_I_frame = state.I_rframes.Cr
    mvd_y,mvd_x = full_luma_search(Y, ref_Y_I_frame, state)
    # make sure to use the correct reference region for the residuals!
    mvd_y_chroma = mvd_y//2
    mvd_x_chroma = mvd_x//2
    ref_Y_I = ref_Y_I_frame[Y][mvd_y:mvd_y+16,mvd_x:mvd_x+16]
    ref_Cb_I = ref_Cb_I_frame[Cb][mvd_y_chroma:mvd_y_chroma+8,mvd_x_chroma:mvd_x_chroma+8]
    ref_Cr_I = ref_Cr_I_frame[Cr][mvd_y_chroma:mvd_y_chroma+8,mvd_x_chroma:mvd_x_chroma+8]
    copy(Y_pred, ref_Y_I)
    copy(Cb_pred, ref_Cb_I)
    copy(Cr_pred, ref_Cr_I)
    error(Y, Y_pred, Y_error)
    error(Cb, Cb_pred, Cb_error)
    error(Cr, Cr_pred, Cr_error)
    error_pack = Pack(View(Y_error),View(Cb_error),View(Cr_error))
    pred_pack = Pack(View(Y_pred),View(Cb_pred),View(Cr_pred))
    a,b = MacroblockLayer.process_blocks(error_pack, pred_pack, False, state)
    return a,b,mvd_y,mvd_x

  def get_bit_count(rles, is_intra_mblk):
    count = 0
    for rle in rles:
      count += PseudoBlockLayer.pseudo_commit(rle, is_intra_mblk)
    return count
      
  # Run the various prediction modes and pick the best one
  def predict(mblks, rmblks, state):
    Y_rmblk,Cb_rmblk,Cr_rmblk = rmblks
    # start with intra mode, which is always safe to run
    rpack,rle = MacroblockLayer.intra(mblks, state)
    nbits = MacroblockLayer.get_bit_count(rle, True)
    rdo_J = sad(mblks.Y, rpack.Y) #J(mblks.Y, rpack.Y, nbits, state.qp_init)
#    print f'intra {rdo_J}'
    mtype = INTRA0    
    mvd_y,mvd_x = 0,0
    if not state.is_intra_frame:
#      rpack2,rle2 = MacroblockLayer.inter(mblks, state)
#      nbits2 = MacroblockLayer.get_bit_count(rle2, False)
#      rdo_J2 = sad(mblks.Y, rpack2.Y) #J(mblks.Y, rpack2.Y, nbits2, state.qp_init)
#      mtype2 = INTER0
##      if rdo_J2 < rdo_J:
#      rdo_J = rdo_J2        
#      nbits = nbits2
#      mtype = mtype2
#      rle = rle2
#      rpack = rpack2
#      print '===='
#      print mblks.Cr.str_like(int)
#      print rpack.Cr.str_like(int)
      # TODO add a configuration flag to turn this off
      rpack2,rle2,mvd_y2,mvd_x2 = MacroblockLayer.inter_me(mblks, state)
      print mvd_y2,mvd_x2
#      exit(48)
      nbits2 = MacroblockLayer.get_bit_count(rle2, False)
      mtype2 = INTER_MC1
      rdo_J2 = sad(mblks.Y, rpack2.Y)#J(mblks.Y, rpack2.Y, nbits2, state.qp_init)
#      if rdo_J2 < rdo_J:
      rdo_J = rdo_J2
      nbits = nbits2
      mtype = mtype2
      rle = rle2
      rpack = rpack2
      mvd_y = mvd_y2
      mvd_x = mvd_x2
    # Copy over reconstruction
    for i in range(16):
      for j in range(16):
        Y_rmblk[i,j] = rpack.Y(i,j)
    for i in range(8):
      for j in range(8):
        Cb_rmblk[i,j] = rpack.Cb(i,j)
        Cr_rmblk[i,j] = rpack.Cr(i,j)
    return mtype,rle,mvd_y,mvd_x

  def process(mblks, rmblks, state):
    mtype,rles,mvd_y,mvd_x = MacroblockLayer.predict(mblks, rmblks, state)
    MacroblockLayer.commit_header(mtype, rles, mvd_y, mvd_x, state)
    transmitted = False
    if has_tcoeff(mtype):
      for rle in rles:
        transmitted |= BlockLayer.commit(rle, is_intra(mtype), state.bitstream)
    else:
      transmitted = True
    state.bitstream.compressed.pack(MBA_stuffing_codeword, MBA_stuffing_nbits)
    return transmitted
    
  # Write macroblock header to the bitstream
  def commit_header(mtype, rles, mvd_y, mvd_x, state):
    addr_to_transmit = 1 if state.midx == 1 else state.midx - state.l_midx
    code,nbits = MBA_codewords[addr_to_transmit-1], MBA_nbits[addr_to_transmit-1] # -1 b/c it is a 1-based index
    state.bitstream.compressed.pack(code, nbits)
    code,nbits = 1, mtype_nbits[mtype]
    state.bitstream.compressed.pack(code, nbits)
    if has_mquant(mtype):
      assert False
      state.bitstream.compressed.pack(state.mquant, 5)
    if has_mvd(mtype):
      last_mvd_y = state.l_mvd_y
      last_mvd_x = state.l_mvd_x
      if state.midx == 1 or state.midx == 12 or state.midx == 23 or addr_to_transmit != 1 or not has_mvd(state.l_mtype):
        last_mvd_y = 0
        last_mvd_x = 0
      diff_mvd_y = mvd_y - last_mvd_y
      diff_mvd_x = mvd_x - last_mvd_x
      code,nbits = mvd_vlc[diff_mvd_y]
      state.bitstream.compressed.pack(code,nbits)
      code,nbits = mvd_vlc[diff_mvd_x]
      state.bitstream.compressed.pack(code,nbits)
      state.l_mvd_y = mvd_y
      state.l_mvd_x = mvd_x
    if has_cbp(mtype):
      cbp = 0
      mult = 32
      for rle in rles:
        if len(rle) != 0:
          # at least one nonzero
          cbp += mult
        mult //= 2
      code,nbits = CBP_vlc[cbp-1]
      state.bitstream.compressed.pack(code,nbits)
    state.l_mtype = mtype
    
class GOBLayer:

  def process(gobs, rgobs, gn, state):
    # can immediately commit the header
    state.bitstream.compressed.pack(GBSC, 16)
    state.bitstream.compressed.pack(gn, 4)
    state.bitstream.compressed.pack(state.gquant, 5)
    state.bitstream.compressed.pack(0, 1) # GEI
    state.bitstream.compressed.pack(MBA_stuffing_codeword, MBA_stuffing_nbits)
    # now do macroblock things
    return GOBLayer.encode(gobs, rgobs, state)

  def encode(gobs, rgobs, state):
    Y_gob,Cb_gob,Cr_gob = gobs
    Y_rgob,Cb_rgob,Cr_rgob = rgobs
    state.midx = 1
    # True if any macroblock in the GOB gets transmitted
    transmitted = False
    for Y_mblk,Cb_mblk,Cr_mblk in zip(Y_gob.grid((16,16)),Cb_gob.grid((8,8)),Cr_gob.grid((8,8))):
      mblks = Pack(Y_mblk, Cb_mblk, Cr_mblk)
      rmblks = Pack(Y_rgob[Y_mblk], Cb_rgob[Cb_mblk], Cr_rgob[Cr_mblk])
      t = MacroblockLayer.process(mblks, rmblks, state)
      if t:
        state.l_midx = state.midx
        transmitted = True
      state.midx += 1      
    return transmitted

class PicLayer:

  def process(frames, rframes, ptype, state):
    # can immediately commit the header
    tr = state.frame_idx
    state.bitstream.compressed.pack(PSC, 20)
    state.bitstream.compressed.pack(tr, 5)
    state.bitstream.compressed.pack(ptype, 6)
    state.bitstream.compressed.pack(0, 1) # pei
    # now do GOB things
    return PicLayer.encode(frames, rframes, state)

  def encode(frames, rframes, state):
    Y_frame,Cb_frame,Cr_frame = frames
    Y_rframe,Cb_rframe,Cr_rframe = rframes
    gn = 1
    incr = 1 if state.cif else 2
    transmitted = False
    for Y_gob,Cb_gob,Cr_gob in zip(Y_frame.grid((48,176)),Cb_frame.grid((24,88)),Cr_frame.grid((24,88))):
      gobs = Pack(Y_gob, Cb_gob, Cr_gob)
      rgobs = Pack(Y_rframe[Y_gob], Cb_rframe[Cb_gob], Cr_rframe[Cr_gob])
      transmitted |= GOBLayer.process(gobs, rgobs, gn, state)
      gn += incr
    # if false, the whole picture was skipped
#    state.bitstream.compressed.align(1)
    return transmitted
      
      



