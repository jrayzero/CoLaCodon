from cola.blocks import *
from ..common.typedefs import *
from dct import *
from quantize import *
from constants import *
from inter import *
from h261_bitstream import *

zigzag = [(0,0),(0,1),(1,0),(2,0),(1,1),(0,2),(0,3),(1,2),
          (2,1),(3,0),(4,0),(3,1),(2,2),(1,3),(0,4),(0,5),
          (1,4),(2,3),(3,2),(4,1),(5,0),(6,0),(5,1),(4,2),
          (3,3),(2,4),(1,5),(0,6),(0,7),(1,6),(2,5),(3,4),
          (4,3),(5,2),(6,1),(7,0),(7,1),(6,2),(5,3),(4,4),
          (3,5),(2,6),(1,7),(2,7),(3,6),(4,5),(5,4),(6,3),
          (7,2),(7,3),(6,4),(5,5),(4,6),(3,7),(4,7),(5,6),
          (6,5),(7,4),(7,5),(6,6),(5,7),(6,7),(7,6),(7,7)]

MBA_codewords = [
  1,  3,  2,  3,
  2,  3,  2,  7,
  6, 11, 10,  9,
  8,  7,  6, 23,
  22, 21, 20, 19,
  18, 35, 34, 33,
  32, 31, 30, 29,
  28, 27, 26, 25,
  24,
  15, # (MBA stuffing)
  1]  # (start code)

MBA_nbits = [
  1,  3,  3,  4,
  4,  5,  5,  7,
  7,  8,  8,  8,
  8,  8,  8, 10,
  10, 10, 10, 10,
  10, 11, 11, 11,
  11, 11, 11, 11,
  11, 11, 11, 11,
  11,
  11, # (MBA stuffing)
  16]  # (start code)

mtype_nbits = [4, 7, 1, 5, 9, 8, 10, 3, 2, 6]

mvd_codewords_nbits = [
  (  1, 1 ), (  1, 2 ), ( 1, 3 ), (  1,  4 ), (  3,  6 ), (  5,  7 ), (  4,  7 ), (  3,  7 ),
  ( 11, 9 ), ( 10, 9 ), ( 9, 9 ), ( 17, 10 ), ( 16, 10 ), ( 15, 10 ), ( 14, 10 ), ( 13, 10 ), ( 12, 10 )]

CBP_vlc = [( 11, 5 ), (  9, 5 ), ( 13, 6 ), ( 13, 4 ), ( 23, 7 ), ( 19, 7 ), ( 31, 8 ), ( 12, 4 ),
           ( 22, 7 ), ( 18, 7 ), ( 30, 8 ), ( 19, 5 ), ( 27, 8 ), ( 23, 8 ), ( 19, 8 ), ( 11, 4 ),
           ( 21, 7 ), ( 17, 7 ), ( 29, 8 ), ( 17, 5 ), ( 25, 8 ), ( 21, 8 ), ( 17, 8 ), ( 15, 6 ),
           ( 15, 8 ), ( 13, 8 ), (  3, 9 ), ( 15, 5 ), ( 11, 8 ), (  7, 8 ), (  7, 9 ), ( 10, 4 ),
           ( 20, 7 ), ( 16, 7 ), ( 28, 8 ), ( 14, 6 ), ( 14, 8 ), ( 12, 8 ), (  2, 9 ), ( 16, 5 ),
           ( 24, 8 ), ( 20, 8 ), ( 16, 8 ), ( 14, 5 ), ( 10, 8 ), (  6, 8 ), (  6, 9 ), ( 18, 5 ),
           ( 26, 8 ), ( 22, 8 ), ( 18, 8 ), ( 13, 5 ), (  9, 8 ), (  5, 8 ), (  5, 9 ), ( 12, 5 ),
           (  8, 8 ), (  4, 8 ), (  4, 9 ), (  7, 3 ), ( 10, 5 ), (  8, 5 ), ( 12, 6 )]

tcoeff_vlc = {0:{2:(0b0100,4), 3:(0b00101,5), 4:(0b0000110,7), 5:(0b00100110,8), 
                 6:(0b00100001,8), 7:(0b0000001010,10), 8:(0b000000011101,12),
                 9:(0b000000011000,12), 10:(0b000000010011,12), 11:(0b000000010000,12), 12:(0b0000000011010,13), 13:(0b0000000011001,13),
                 14:(0b0000000011000,13), 15:(0b0000000010111,13)},
              1:{1:(0b011,3), 2:(0b000110,6), 3:(0b00100101,8), 4:(0b0000001100,10), 
                 5:(0b000000011011,12), 6:(0b0000000010110,13), 7:(0b0000000010101,13)},
              2:{1:(0b0101,4), 2:(0b0000100,7), 3:(0b00100101,8), 4:(0b0000001100,10), 5:(0b000000011011,12)},
              3:{1:(0b00111,5), 2:(0b00100100,8), 3:(0b000000011100,12), 4:(0b0000000010011,13)},
              4:{1:(0b00110,5), 2:(0b0000001111,10), 3:(0b000000010010,12)},
              5:{1:(0b000111,6), 2:(0b0000001001,10), 3:(0b0000000010010,13)},
              6:{1:(0b000101,6), 2:(0b000000011110,12)},
              7:{1:(0b000100,6), 2:(0b000000010101,12)},
              8:{1:(0b0000111,7), 2:(0b000000010001,12)},
              9:{1:(0b0000101,7), 2:(0b0000000010001,13)},
              10:{1:(0b00100111,8), 2:(0b0000000010000,13)},
              11:{1:(0b00100011,8)},
              12:{1:(0b00100010,8)},
              13:{1:(0b00100000,8)},
              14:{1:(0b0000001110,10)},
              15:{1:(0b0000001101,10)},
              16:{1:(0b0000001000,10)},
              17:{1:(0b000000011111,12)},
              18:{1:(0b000000011010,12)},
              19:{1:(0b000000011001,12)},
              20:{1:(0b000000010111,12)},
              21:{1:(0b000000010110,12)},
              22:{1:(0b0000000011111,13)},
              23:{1:(0b0000000011110,13)},
              24:{1:(0b0000000011101,13)},
              25:{1:(0b0000000011100,13)},
              26:{1:(0b0000000011011,13)}}

# A collection of Y, Cb, and Cr components
@tuple
class Pack[T]:
  Y: View[T,Tup2]
  Cb: View[T,Tup2]
  Cr: View[T,Tup2]

# any necessary parameters to pass around
@dataclass(init=False)
class H261State:
  # whether CIF
  cif: bool
  # The original quantization value
  qp_init: int
  # The current qp value
  qp: int
  # Whether intra or inter frame
  is_intra_frame: bool
  # Current frame index
  frame_idx: int
  # The bitstream
  bitstream: H261Bitstream
  # current gquant qp
  gquant: int
  # current mquant qp
  mquant: int
  # current macroblock idx
  midx: int
  # last macroblock idx
  l_midx: int
  # last mtype
  l_mtype: int
  # the prior encoded reconstructed I frames
  I_rframes: Optional[Pack[int]]

  def __init__(self, qp_init, cif, bitstream):
    self.qp_init = qp_init
    self.qp = qp_init
    self.gquant = qp_init
    self.mquant = qp_init
    self.cif = cif
    self.bitstream = bitstream
    self.is_intra_frame = False
    self.frame_idx = 0
    self.midx = 0
    self.l_midx = 0
    self.l_mtype = 0
    self.I_rframes = None

class PseudoBlockLayer:

  def pseudo_add_sign():
    return 1

  def pseudo_maybe_vlc(run,coeff):
    if run in tcoeff_vlc:
      run_info = tcoeff_vlc[run]
      if coeff in run_info:
        # vlc
        scoeff = coeff
        if coeff < 0:
          coeff = -coeff
        codeword,nbits = run_info[coeff]
        nbits += PseudoBlockLayer.pseudo_add_sign()
        return True,nbits
    return False,0

  def pseudo_flc():
    return tcoeff_escape_nbits + 14

  # Don't actually write to bitstream--just figure out how many bits are needed
  def pseudo_commit(rle, is_intra_mblock):
    cost = 0
    if not is_intra_mblock and len(rle) == 0:
      # don't need to transmit this block
      return cost
    # for coeff, if it is negative, you use the absolute value to actually look up 
    # in the VLC table.
    # for the FLC, you use the unsigned value
    # when using fixed run/level codes, its just the straightup bit representation
    if is_intra_mblock:
      cost += 8
    else:
      # the first transmitted level gets special treatment if run == 0 and coeff == 1
      first_run = rle[0]
      if first_run[0] == 0 and (first_run[1] == 1 or first_run[1] == -1):
        cost += 1
        cost += PseudoBlockLayer.pseudo_add_sign()
      else:
        zrun = first_run[0]
        coeff = first_run[1]
        res = PseudoBlockLayer.pseudo_maybe_vlc(zrun, coeff)
        if not res[0]:
          cost += PseudoBlockLayer.pseudo_flc()
        else:
          cost += res[1]
    for zrun,coeff in rle[1:]:
      if zrun == 0 and (coeff == 1 or coeff == -1):
        cost += 2
        cost += PseudoBlockLayer.pseudo_add_sign()
      else:
        res = PseudoBlockLayer.pseudo_maybe_vlc(zrun, coeff)
        if not res[0]:
          cost += PseudoBlockLayer.pseudo_flc()
        else:
          cost += res[1]
      first = False
    cost += tcoeff_EOB_nbits
    return cost

# No prediction actually happens at the block layer. Rather, this is what
# actually processes each 8x8 block   
class BlockLayer:

  # if is_intra == True, use special marker for the DC value
  def rle(coeffs, is_intra_mblk):
    # RLE in zigzag order
    # if intra, include the DC separately
    run = 0
    runs = []
    first = True
    for zz in zigzag:
      coeff = coeffs(*zz)
      if is_intra_mblk and first == True:
        dc = coeff
        runs.append((0,dc)) # special value
        first = False
        continue
      first = False
      if coeff == 0:
        run += 1
      else:
        runs.append((run,coeff))
        run = 0
    # don't need the last run because it'll just be EOB
    return runs

  def forward(coeffs, is_intra_mblk, qp):
    chen_DCT(coeffs)
    if is_intra_mblk:
      intra_quantize(coeffs, qp) 
      dc = coeffs(0,0)
      if dc > 254:
        dc = 254
      elif dc < 1:
        dc = 1
      coeffs[0,0] = dc
    else:
      quantize(coeffs, qp)
    dc = coeffs(0,0)
    clip(coeffs, -127, 127)
    coeffs[0,0] = clip1(dc, 1, 254)

  def backward(coeffs, out_coeffs, is_intra_mblk, qp):
    if is_intra_mblk:
      intra_iquantize(coeffs, out_coeffs, qp)
    else:
      iquantize(coeffs, out_coeffs, qp)
    chen_IDCT(out_coeffs)
    clip(out_coeffs, 0, 255)
    
  # add the prediction back on to the reconstruction
  def reconstruct(rblock, pred):
    for i in range(8):
      for j in range(8):
        rblock[i,j] = rblock(i,j) + pred(i,j)

  def process(pred, rpred, is_intra_mblk, state):
    BlockLayer.forward(pred, is_intra_mblk, state.qp)
    BlockLayer.backward(pred, rpred[pred], is_intra_mblk, state.qp)
    if not is_intra_mblk:
      BlockLayer.reconstruct(rpred[pred], pred)
    rle = BlockLayer.rle(pred, is_intra_mblk)
    return rle
    
  def add_sign(coeff, bitstream):
    if coeff < 0:
      bitstream.compressed.pack(1,1)
    else:
      bitstream.compressed.pack(0,1)

  # see if there is a variable length code in the table, and use that if so
  # otherwise, returns false and need to use the fixed length code
  def maybe_vlc(run,coeff,bitstream):
    if run in tcoeff_vlc:
      run_info = tcoeff_vlc[run]
      if coeff in run_info:
        # vlc
        scoeff = coeff
        if coeff < 0:
          coeff = -coeff
        codeword,nbits = run_info[coeff]
        bitstream.compressed.pack(codeword,nbits)
        BlockLayer.add_sign(coeff, bitstream)
        return True
    return False

  def flc(run, coeff, bitstream):
    bitstream.compressed.pack(tcoeff_escape_codeword, tcoeff_escape_nbits)
    bitstream.compressed.pack(run, 6)
    bitstream.compressed.pack(coeff, 8)    

  def commit(rle, is_intra_mblock, bitstream):
    if not is_intra_mblock and len(rle) == 0:
      # don't need to transmit this block
      return False
    # for coeff, if it is negative, you use the absolute value to actually look up 
    # in the VLC table.
    # for the FLC, you use the unsigned value
    # when using fixed run/level codes, its just the straightup bit representation
    if is_intra_mblock:
      dc = rle[0][1]
      if dc == 128:
        bitstream.compressed.pack(0xFF,8)
      else:
        bitstream.compressed.pack(dc,8)
    else:
      # the first transmitted level gets special treatment if run == 0 and coeff == 1
      first_run = rle[0]
      if first_run[0] == 0 and (first_run[1] == 1 or first_run[1] == -1):
        bitstream.compressed.pack(1,1)
        BlockLayer.add_sign(first_run[1], bitstream)
      else:
        zrun = first_run[0]
        coeff = first_run[1]
        if not BlockLayer.maybe_vlc(zrun, coeff, bitstream):
          BlockLayer.flc(zrun, coeff, bitstream)
    for zrun,coeff in rle[1:]:
      if zrun == 0 and (coeff == 1 or coeff == -1):
        bitstream.compressed.pack(0b11,2) # not first coeff in block
        BlockLayer.add_sign(coeff, bitstream)
      else:
        if not BlockLayer.maybe_vlc(zrun, coeff, bitstream):
          BlockLayer.flc(zrun, coeff, bitstream)       
      first = False
    bitstream.compressed.pack(tcoeff_EOB_codeword, tcoeff_EOB_nbits)
    return True

class MacroblockLayer:

  # Run intra prediction and store in temporaries
  def intra(mblks, state):
    Y,Cb,Cr = mblks
    Y_pred, Cb_pred, Cr_pred = Block[int,Tup2](Y),Block[int,Tup2](Cb),Block[int,Tup2](Cr),
    Y_recons, Cb_recons, Cr_recons = Block[int,Tup2](Y),Block[int,Tup2](Cb),Block[int,Tup2](Cr),
    for i in range(16):
      for j in range(16):
        Y_pred[i,j] = int(Y(i,j))
    for i in range(8):
      for j in range(8):
        Cb_pred[i,j] = int(Cb(i,j))
        Cr_pred[i,j] = int(Cr(i,j))
    intra_pack = Pack(View(Y_pred),View(Cb_pred),View(Cr_pred))
    intra_rpack = Pack(View(Y_recons),View(Cb_recons),View(Cr_recons))
    rle = []
    for Y in Y_pred.grid((8,8)):
      rle.append(BlockLayer.process(Y, Y_recons, False, state))
    rle.append(BlockLayer.process(Cb_pred, Cb_recons, False, state))    
    rle.append(BlockLayer.process(Cr_pred, Cr_recons, False, state))
    return intra_pack,intra_rpack,rle

  # Run the various prediction modes and pick the best one
  def predict(mblks, rmblks, state):
    # start with intra mode, which is always safe to run
    intra_pack,intra_rpack,intra_rle = MacroblockLayer.intra(mblks, state)
    # Left off here--count the number of bits, do the tradeoff, then pick the best
    # start with just intra and get that whole process working again. Basically,
    # be exhaustive
    return INTRA0,intra_rle

  def process(mblks, rmblks, state):
    mtype,rle = MacroblockLayer.predict(mblks, rmblks, state)
    MacroblockLayer.commit_header(mtype,rle, state)
    transmitted = False
    for r in rle:
      transmitted |= BlockLayer.commit(r, True, state.bitstream)
    state.bitstream.compressed.pack(MBA_stuffing_codeword, MBA_stuffing_nbits)
    return transmitted
    
  # Write macroblock header to the bitstream
  def commit_header(mtype, rles, state):
    addr_to_transmit = 1 if state.midx == 1 else state.midx - state.l_midx
    code,nbits = MBA_codewords[addr_to_transmit-1], MBA_nbits[addr_to_transmit-1] # -1 b/c it is a 1-based index
    state.bitstream.compressed.pack(code, nbits)
    code,nbits = 1, mtype_nbits[mtype]
    state.bitstream.compressed.pack(code, nbits)
    if has_mquant(mtype):
      assert False
      state.bitstream.compressed.pack(state.mquant, 5)
    if has_mvd(mtype):
      assert False # Need to figure out the mvd codewords
#      if self.addr == 1 or self.addr == 12 or self.addr == 23 or addr_to_transmit != 1 or not has_mvd(state.last_mtype)
#        last_mvd_H = 0
#        last_mvd_V = 0
#      mvd_H = self.mvd_H - last_mvd_H
#      mvd_V = self.mvd_V - last_mvd_V
#      code,nbits = mvd_codewords[mvd_h+16],mvd_nbits[mvd_h+16]
#      bitstream.compressed.pack(code,nbits)
#      code,nbits = mvd_codewords[mvd_V+16],mvd_nbits[mvd_V+16]
#      bitstream.compressed.pack(code,nbits)      
    if has_cbp(mtype):
      cbp = 0
      mult = 32
      for rle in rles:
        if len(rle) != 0:
          # at least one nonzero
          cbp += mult
        mult //= 2
      code,nbits = CBP_vlc[cbp-1]
      state.bitstream.compressed.pack(code,nbits)
    state.l_mtype = mtype
    
class GOBLayer:

  def process(gobs, rgobs, gn, state):
    # can immediately commit the header
    state.bitstream.compressed.pack(GBSC, 16)
    state.bitstream.compressed.pack(gn, 4)
    state.bitstream.compressed.pack(state.gquant, 5)
    state.bitstream.compressed.pack(0, 1) # GEI
    state.bitstream.compressed.pack(MBA_stuffing_codeword, MBA_stuffing_nbits)
    # now do macroblock things
    return GOBLayer.encode(gobs, rgobs, state)

  def encode(gobs, rgobs, state):
    Y_gob,Cb_gob,Cr_gob = gobs
    Y_rgob,Cb_rgob,Cr_rgob = rgobs
    state.midx = 1
    # True if any macroblock in the GOB gets transmitted
    transmitted = False
    for Y_mblk,Cb_mblk,Cr_mblk in zip(Y_gob.grid((16,16)),Cb_gob.grid((8,8)),Cr_gob.grid((8,8))):
      mblks = Pack(Y_mblk, Cb_mblk, Cr_mblk)
      rmblks = Pack(Y_rgob[Y_mblk], Cb_rgob[Cb_mblk], Cr_rgob[Cr_rgob])
      t = MacroblockLayer.process(mblks, rmblks, state)
      if t:
        state.l_midx = state.midx
        transmitted = True
      state.midx += 1      
    return transmitted

class PicLayer:

  def process(frames, rframes, ptype, state):
    # can immediately commit the header
    tr = state.frame_idx
    state.bitstream.compressed.pack(PSC, 20)
    state.bitstream.compressed.pack(tr, 5)
    state.bitstream.compressed.pack(ptype, 6)
    state.bitstream.compressed.pack(0, 1) # pei
    # now do GOB things
    return PicLayer.encode(frames, rframes, state)

  def encode(frames, rframes, state):
    Y_frame,Cb_frame,Cr_frame = frames
    Y_rframe,Cb_rframe,Cr_rframe = rframes
    gn = 1
    incr = 1 if state.cif else 2
    transmitted = False
    for Y_gob,Cb_gob,Cr_gob in zip(Y_frame.grid((48,176)),Cb_frame.grid((24,88)),Cr_frame.grid((24,88))):
      gobs = Pack(Y_gob, Cb_gob, Cr_gob)
      rgobs = Pack(Y_rframe[Y_gob], Cb_rframe[Cr_gob], Cr_rframe[Cb_gob])
      transmitted |= GOBLayer.process(gobs, rgobs, gn, state)
      gn += incr
    # if false, the whole picture was skipped
#    state.bitstream.compressed.align(1)
    return transmitted
      
      



