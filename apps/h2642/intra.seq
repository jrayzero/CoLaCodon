from cola.blocks import *
from video import *
from funcs import *
from transform import *
from quant import *

def residual4x4(A,B,out):
  for y in range(4):
    for x in range(4):
      out[y,x] = int(A(y,x))-int(B(y,x))

def intra_chroma_4x4_DC_1(pred, ref_left, ref_up):
  s = 4
  for v in ref_left[:,-1]:
    s += v
  for v in ref_up[-1,:]:
    s += v
  s >>= 3
  for y in range(4):
    for x in range(4):
      pred[y,x] = s  

def intra_chroma_4x4_DC_2(pred, ref_left):
  s = 2
  for v in ref_left[:,-1]:
    s += v
  s >>= 2
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_chroma_4x4_DC_3(pred, ref_up):
  s = 2
  for v in ref_up[-1,:]:
    s += v
  s >>= 2
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_chroma_4x4_DC_4(pred, bit_depth):
  s = (1<<(bit_depth-1))
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_4x4_vertical(pred, ref):
  p = ref[pred]
  for y in range(4):
    for x in range(4):
      pred[y,x] = p(-1,x)

def intra_4x4_horizontal(pred, ref):
  p = ref[pred]
  for y in range(4):
    for x in range(4):
      pred[y,x] = p(y,-1)

def intra_4x4_DC_1(pred, ref):
  p = ref
  s = 4
  for v in p[-1,:]:
    s += v
  for v in p[:,-1]:
    s += v
  s >>= 3
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_4x4_DC_2(pred, ref):
  p = ref
  s = 2
  for v in p[:,-1]:
    s += v
  s >>= 2
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_4x4_DC_3(pred, ref):
  p = ref
  s = 2
  for v in p[-1,:]:
    s += v
  s >>= 2
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

def intra_4x4_DC_4(pred, bit_depth):
  s = (1<<(bit_depth-1))
  for y in range(4):
    for x in range(4):
      pred[y,x] = s

# TODO TODO If either A or B is 16x16 (and you are 4x4), you HAVE to use the DC mode
def luma_intra_predict_4x4(mblk: MacroblockLayer, encoder_frame: EncoderFrame, video: Video, quant_tables):
  Y_raw_mblk_16x16 = mblk.Y_raw_mblk_16x16
  Y_recons_frame = encoder_frame.Y_recons_frame
  qp = video.cfg.qp_init
  mblk.Y_pre_code_mblk_16x16 = Block[int,Tup2](Y_raw_mblk_16x16)
  for Y_smblk_8x8 in Y_raw_mblk_16x16.grid((8,8)):
    for Y_smblk_4x4 in Y_smblk_8x8.grid((4,4)):
      Y_pred_smblk_4x4 = Block[int,Tup2](Y_smblk_4x4)
      if Y_smblk_4x4[-1,-1].exists():
        intra_4x4_DC_1(Y_pred_smblk_4x4, Y_recons_frame[Y_pred_smblk_4x4])
      elif Y_smblk_4x4[0,-1].exists():
        intra_4x4_DC_2(Y_pred_smblk_4x4, Y_recons_frame[Y_pred_smblk_4x4])
      elif Y_smblk_4x4[-1,0].exists():
        intra_4x4_DC_3(Y_pred_smblk_4x4, Y_recons_frame[Y_pred_smblk_4x4]) 
      else:
        intra_4x4_DC_4(Y_pred_smblk_4x4, 8)
      cost = sad(Y_pred_smblk_4x4, Y_smblk_4x4)      
      # forward      
      Y_pre_code_smblk_4x4 = mblk.Y_pre_code_mblk_16x16[Y_pred_smblk_4x4]
      Y_recons_4x4 = Y_recons_frame[Y_pred_smblk_4x4]
      residual4x4(Y_smblk_4x4, Y_pred_smblk_4x4, Y_pre_code_smblk_4x4)
      dct4x4(Y_pre_code_smblk_4x4, Y_pre_code_smblk_4x4)
      basic_quantization(Y_pre_code_smblk_4x4, Y_pre_code_smblk_4x4, qp, quant_tables)
      ncoeffs = 0
      for coeff in Y_pre_code_smblk_4x4:
        if coeff != 0:
          ncoeffs += 1
      # reconstruct
      pre_idct_scale(Y_pre_code_smblk_4x4, Y_recons_4x4, qp, quant_tables)
      idct4x4(Y_recons_4x4, Y_recons_4x4)
      post_idct_scale(Y_recons_4x4, Y_recons_4x4)
      for i in range(4):
        for j in range(4):
          Y_recons_4x4[i,j] = Y_recons_4x4(i,j) + Y_pred_smblk_4x4(i,j)
      # record how this block was predicted
      # TODO this assumes just this 4x4 mode
      Y_pred_modes_smblk_4x4 = encoder_frame.Y_pred_modes_frame[Y_pred_smblk_4x4]
      Y_nz_smblk_4x4 = encoder_frame.Y_nz_coeffs_frame[Y_pred_smblk_4x4]
      for i in range(4):
        for j in range(4):
          Y_pred_modes_smblk_4x4[i,j] = intra_luma_4x4_DC
          Y_nz_smblk_4x4[i,j] = ncoeffs


def chroma_part1(C_raw_smblk_4x4, C_pred_smblk_4x4, C_recons_smblk_4x4):
  residual4x4(C_raw_smblk_4x4, C_pred_smblk_4x4, C_recons_smblk_4x4)
  dct4x4(C_recons_smblk_4x4, C_recons_smblk_4x4)

def chroma_part2(C_recons_mblk_8x8, C_pred_mblk_8x8, C_pre_code_smblk_8x8, C_nz_coeffs_8x8, qp, video, quant_tables):
  # more forward
  dcs_2x2 = C_recons_mblk_8x8[::4,::4]
  hadamard2x2(dcs_2x2, dcs_2x2)
  for C_recons_smblk_4x4 in C_recons_mblk_8x8.grid((4,4)):
    #basic_quantization(C_recons_smblk_4x4, C_recons_smblk_4x4, qp, quant_tables)
    if video.cfg.greyscale:
      for i in range(4):
        for j in range(4):
          C_recons_smblk_4x4[i,j] = 0
    C_nz_smblk_4x4 = C_nz_coeffs_8x8[C_recons_smblk_4x4]
    ncoeffs = 0
    for i in range(4):
      for j in range(4):
        # do not count the DC coeff!
        if i == 0 and j == 0:
          continue
        coeff = C_recons_smblk_4x4(i,j)
        if coeff != 0:
          ncoeffs += 1
    # commit this prediction and copy over to entropy block
    for i in range(4):
      for j in range(4):          
        C_pre_code_smblk_8x8[C_recons_smblk_4x4][i,j] = C_recons_smblk_4x4(i,j)        
        C_nz_smblk_4x4[i,j] = ncoeffs
  # C_reconstruct
  ihadamard2x2(dcs_2x2, dcs_2x2)
  post_hadamard_chroma_DC_scale(dcs_2x2, dcs_2x2, qp, quant_tables)
  for C_recons_smblk_4x4 in C_recons_mblk_8x8.grid((4,4)):
    dc00 = C_recons_smblk_4x4(0,0)
    pre_idct_scale(C_recons_smblk_4x4, C_recons_smblk_4x4, qp, quant_tables)
    C_recons_smblk_4x4[0,0] = dc00 # not scaled, see 8.5.12.1 in spec
    idct4x4(C_recons_smblk_4x4, C_recons_smblk_4x4)
    post_idct_scale(C_recons_smblk_4x4, C_recons_smblk_4x4)
    for i in range(4):
      for j in range(4):
        C_recons_smblk_4x4[i,j] = C_recons_smblk_4x4(i,j) + C_pred_mblk_8x8[C_recons_smblk_4x4](i,j)  

# TODO all the 4x4 blocks get the same mode, so can't switch within the macroblock like you
# can with luma
def chroma_intra_predict_4x4(mblk: MacroblockLayer, encoder_frame: EncoderFrame, video: Video, quant_tables):
  Cb_raw_mblk_8x8 = mblk.Cb_raw_mblk_8x8
  Cr_raw_mblk_8x8 = mblk.Cr_raw_mblk_8x8
  Cb_recons_frame = encoder_frame.Cb_recons_frame
  Cr_recons_frame = encoder_frame.Cr_recons_frame
  qp = video.cfg.qp_init
  Cb_recons_mblk_8x8 = Cb_recons_frame[Cb_raw_mblk_8x8]
  Cr_recons_mblk_8x8 = Cr_recons_frame[Cr_raw_mblk_8x8]
  # we need to store all 4x4 sub predictions
  Cb_pred_mblk_8x8 = Block[int,Tup2](Cb_raw_mblk_8x8)
  Cr_pred_mblk_8x8 = Block[int,Tup2](Cr_raw_mblk_8x8)
  mblk.Cb_pre_code_mblk_8x8 = Block[int,Tup2](Cb_raw_mblk_8x8)
  mblk.Cr_pre_code_mblk_8x8 = Block[int,Tup2](Cr_raw_mblk_8x8)
  y,x = Cb_raw_mblk_8x8.get_starts()
  # chroma is a little funky, and literally every single text (except the spec, of course) neglects to
  # say that the chroma 4x4 blocks don't use 4x4 blocks WITHIN the chroma macroblock for prediction. 
  # Rather, they use only the 4x4 blocks from the surrounding macroblocks (so the bottom-right 4x4 
  # for example is using data ABOVE and LEFT of the MACROBLOCK)
  # just grab the individual 4x4 blocks here
  Cb_ul_4x4,Cr_ul_4x4 = Cb_pred_mblk_8x8[:4,:4],Cr_pred_mblk_8x8[:4,:4]
  Cb_ur_4x4,Cr_ur_4x4 = Cb_pred_mblk_8x8[:4,4:],Cr_pred_mblk_8x8[:4,4:]
  Cb_bl_4x4,Cr_bl_4x4 = Cb_pred_mblk_8x8[4:,:4],Cr_pred_mblk_8x8[4:,:4]
  Cb_br_4x4,Cr_br_4x4 = Cb_pred_mblk_8x8[4:,4:],Cr_pred_mblk_8x8[4:,4:]
  # upper left block
  if y > 0 and x > 0:
    intra_chroma_4x4_DC_1(Cb_ul_4x4, Cb_recons_mblk_8x8[Cb_ul_4x4], Cb_recons_mblk_8x8[Cb_ul_4x4])    
    intra_chroma_4x4_DC_1(Cr_ul_4x4, Cr_recons_mblk_8x8[Cr_ul_4x4], Cr_recons_mblk_8x8[Cr_ul_4x4])    
  elif x > 0:
    intra_chroma_4x4_DC_2(Cb_ul_4x4, Cb_recons_mblk_8x8[Cb_ul_4x4])
    intra_chroma_4x4_DC_2(Cr_ul_4x4, Cr_recons_mblk_8x8[Cr_ul_4x4])
  elif y > 0:
    intra_chroma_4x4_DC_3(Cb_ul_4x4, Cb_recons_mblk_8x8[Cb_ul_4x4])
    intra_chroma_4x4_DC_3(Cr_ul_4x4, Cr_recons_mblk_8x8[Cr_ul_4x4])
  else:
    intra_chroma_4x4_DC_4(Cb_ul_4x4, 8)
    intra_chroma_4x4_DC_4(Cr_ul_4x4, 8)
  # bottom right block
  if y > 0 and x > 0:
    intra_chroma_4x4_DC_1(Cb_br_4x4, Cb_recons_mblk_8x8[Cb_bl_4x4], Cb_recons_mblk_8x8[Cb_ur_4x4])    
    intra_chroma_4x4_DC_1(Cr_br_4x4, Cr_recons_mblk_8x8[Cr_bl_4x4], Cr_recons_mblk_8x8[Cr_ur_4x4])    
  elif x > 0:
    intra_chroma_4x4_DC_2(Cb_br_4x4, Cb_recons_mblk_8x8[Cb_bl_4x4])
    intra_chroma_4x4_DC_2(Cr_br_4x4, Cr_recons_mblk_8x8[Cr_bl_4x4])
  elif y > 0:
    intra_chroma_4x4_DC_3(Cb_br_4x4, Cb_recons_mblk_8x8[Cb_ur_4x4])
    intra_chroma_4x4_DC_3(Cr_br_4x4, Cr_recons_mblk_8x8[Cr_ur_4x4])
  else:
    intra_chroma_4x4_DC_4(Cb_br_4x4, 8)
    intra_chroma_4x4_DC_4(Cr_br_4x4, 8)
  # upper right block
  if y > 0:
    intra_chroma_4x4_DC_3(Cb_ur_4x4, Cb_recons_mblk_8x8[Cb_ur_4x4])
    intra_chroma_4x4_DC_3(Cr_ur_4x4, Cr_recons_mblk_8x8[Cr_ur_4x4])
  elif x > 0:
    intra_chroma_4x4_DC_2(Cb_ur_4x4, Cb_recons_mblk_8x8[Cb_ul_4x4])
    intra_chroma_4x4_DC_2(Cr_ur_4x4, Cr_recons_mblk_8x8[Cr_ul_4x4])
  else:
    intra_chroma_4x4_DC_4(Cb_ur_4x4, 8)
    intra_chroma_4x4_DC_4(Cr_ur_4x4, 8)
  # bottom left block
  if x > 0:
    intra_chroma_4x4_DC_2(Cb_bl_4x4, Cb_recons_mblk_8x8[Cb_bl_4x4])
    intra_chroma_4x4_DC_2(Cr_bl_4x4, Cr_recons_mblk_8x8[Cr_bl_4x4])    
  elif y > 0:
    intra_chroma_4x4_DC_3(Cb_bl_4x4, Cb_recons_mblk_8x8[Cb_ul_4x4])
    intra_chroma_4x4_DC_3(Cr_bl_4x4, Cr_recons_mblk_8x8[Cr_ul_4x4])    
  else:
    intra_chroma_4x4_DC_4(Cb_bl_4x4, 8)
    intra_chroma_4x4_DC_4(Cr_bl_4x4, 8)    
  for Cb_raw_smblk_4x4,Cr_raw_smblk_4x4 in zip(Cb_raw_mblk_8x8.grid((4,4)), Cr_raw_mblk_8x8.grid((4,4))):
    Cb_pred_smblk_4x4 = Cb_pred_mblk_8x8[Cb_raw_smblk_4x4]
    Cr_pred_smblk_4x4 = Cr_pred_mblk_8x8[Cr_raw_smblk_4x4]
    Cb_recons_smblk_4x4 = Cb_recons_mblk_8x8[Cb_raw_smblk_4x4]
    Cr_recons_smblk_4x4 = Cr_recons_mblk_8x8[Cr_raw_smblk_4x4]
    # In chroma, it is valid to just process all this after since we don't need it for prediction
    chroma_part1(Cb_raw_smblk_4x4, Cb_pred_smblk_4x4, Cb_recons_smblk_4x4)
    chroma_part1(Cr_raw_smblk_4x4, Cr_pred_smblk_4x4, Cr_recons_smblk_4x4)
    # TODO this assumes just this 4x4 mode
    C_pred_modes_smblk_4x4 = encoder_frame.C_pred_modes_frame[Cb_pred_smblk_4x4]
    for i in range(4):
      for j in range(4):
        C_pred_modes_smblk_4x4[i,j] = intra_chroma_4x4_DC
  chroma_part2(Cb_recons_mblk_8x8, Cb_pred_mblk_8x8, mblk.Cb_pre_code_mblk_8x8, encoder_frame.Cb_nz_coeffs_frame[Cb_raw_mblk_8x8], qp, video, quant_tables)
  chroma_part2(Cr_recons_mblk_8x8, Cr_pred_mblk_8x8, mblk.Cr_pre_code_mblk_8x8, encoder_frame.Cr_nz_coeffs_frame[Cr_raw_mblk_8x8], qp, video, quant_tables)
